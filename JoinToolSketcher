# версия 0.0.2 от 17-02-2026
import FreeCAD as App
import FreeCADGui as Gui
import Part
import Sketcher
from PySide6 import QtGui, QtCore, QtWidgets

class SmartSurgeryTool(QtCore.QObject):
    def __init__(self):
        super().__init__()
        self.active = False
        self._mw = Gui.getMainWindow()
        self.edges = []
        self.click_points = {}
        self.cursor_pixmap = self._create_circle_pixmap()
        self.custom_cursor = QtGui.QCursor(self.cursor_pixmap, 12, 12)

    def _create_circle_pixmap(self):
        size = 24
        pix = QtGui.QPixmap(size, size)
        pix.fill(QtCore.Qt.transparent)
        painter = QtGui.QPainter(pix)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0, 180), 1.5))
        painter.drawEllipse(4, 4, size-8, size-8)
        painter.end()
        return pix

    def to_v(self, obj):
        """Абсолютно надежное извлечение вектора для API 2026"""
        try:
            if isinstance(obj, list):
                return self.to_v(obj[0]) if len(obj) > 0 else None
            # Если это GeomPoint или вектор с атрибутами
            if hasattr(obj, "Point"):
                p = obj.Point
                return App.Vector(float(p.x), float(p.y), float(p.z))
            if hasattr(obj, "x"):
                return App.Vector(float(obj.x), float(obj.y), float(obj.z))
            if hasattr(obj, "X"):
                return App.Vector(float(obj.X), float(obj.Y), float(obj.Z))
            # Принудительная пересборка, если это уже вектор
            v = App.Vector(obj)
            return App.Vector(float(v.x), float(v.y), float(v.z))
        except:
            return None

    def setEdit(self, doc_name, obj_name):
        """Этот метод ВНУТРИ SelectionObserver поймает смену инструмента"""
        if self.active:
            # Если пользователь кликнул по инструменту, фокус в Selection меняется
            # Если мы видим, что фокус ушел или изменился — выходим
            App.Console.PrintMessage(">>> Smart Surgery: Обнаружено переключение. Самовыключение.\n")
            QtCore.QTimer.singleShot(0, self.finish)

    def Activated(self):
        if self.active: return
        self.active = True
        self.edges = []
        self.click_points = {}
        QtWidgets.QApplication.setOverrideCursor(self.custom_cursor)
        Gui.Selection.addObserver(self)
        self._mw.installEventFilter(self)
        view = Gui.activeView()
        if view and hasattr(view, 'graphicsView'):
            gv = view.graphicsView()
            gv.installEventFilter(self)
            if gv.viewport(): gv.viewport().installEventFilter(self)
        self._mw.statusBar().showMessage("Smart Surgery: Выберите линию и дугу")
        App.Console.PrintMessage("\n>>> Smart Surgery: Активен. ESC для отмены.\n")

    def eventFilter(self, obj, event):
        if not self.active: return False
        # Выход только по ESC или ПКМ
        if (event.type() == QtCore.QEvent.KeyPress and event.key() == QtCore.Qt.Key_Escape) or \
           (event.type() == QtCore.QEvent.MouseButtonPress and event.button() == QtCore.Qt.RightButton):
            App.Console.PrintMessage(">>> Завершение работы инструмента по запросу пользователя.\n")
            QtCore.QTimer.singleShot(0, self.finish)
            return True
        return False


    def addSelection(self, doc_name, obj_name, sub, pnt):
        if not self.active or not sub or "Edge" not in sub:
            return
        doc = App.getDocument(doc_name)
        if not doc: return
        obj = doc.getObject(obj_name)
        if not obj or not obj.isDerivedFrom("Sketcher::SketchObject"): 
            return
        try:
            idx = int(sub.replace("Edge", "")) - 1
            self.click_points[idx] = self.to_v(pnt)
            if idx not in self.edges:
                self.edges.append(idx)
                App.Console.PrintMessage(f"Выбрано {len(self.edges)}/2: {sub}\n")
            if len(self.edges) == 2:
                # 1. Выполняем операцию
                self.execute(obj)
                # 2. СБРОС ДАННЫХ ДЛЯ ЦИКЛА (Вместо finish)
                self.edges = []
                self.click_points = {}
                Gui.Selection.clearSelection()
                self._mw.statusBar().showMessage("Smart Surgery: Готов к новой паре.")
                App.Console.PrintMessage(">>> Готов к следующей паре (ESC для выхода)...\n")
        except Exception as e:
            App.Console.PrintError(f"Ошибка выбора: {str(e)}\n")

    def reset_tool(self):
        """Сбрасывает накопленные данные для следующего шага, не выключая макрос"""
        self.edges = []
        self.click_points = {}
        Gui.Selection.clearSelection() # Снимаем подсветку с ребер
        self._mw.statusBar().showMessage("Smart Surgery: Готов к новой операции. Выберите 2 ребра.")
        App.Console.PrintMessage(">>> Готов к следующей паре...\n")

    def execute(self, sketch):
        if len(self.edges) < 2:
            return
        idx1, idx2 = self.edges[0], self.edges[1]
        g1, g2 = sketch.Geometry[idx1], sketch.Geometry[idx2]
        App.ActiveDocument.openTransaction("Smart Surgery Fix 2026")
        try:
            # --- ОПРЕДЕЛЯЕМ, КТО ЛИНИЯ, А КТО ДУГА ---
            if isinstance(g1, Part.ArcOfCircle):
                arc_idx = idx1
                line_idx = idx2
            elif isinstance(g2, Part.ArcOfCircle):
                arc_idx = idx2
                line_idx = idx1
            else:
                # Линия + Линия
                arc_idx = None
                line_idx = idx1  # просто первая линия
            # --- ИЗВЛЕКАЕМ ТОЧКИ ГЕОМЕТРИИ ---
            v1s, v1e = self.to_v(g1.StartPoint), self.to_v(g1.EndPoint)
            v2s, v2e = self.to_v(g2.StartPoint), self.to_v(g2.EndPoint)
            # --- СОЗДАЁМ БЕСКОНЕЧНЫЕ КРИВЫЕ ДЛЯ ПЕРЕСЕЧЕНИЯ ---
            c1 = g1.Circle if isinstance(g1, Part.ArcOfCircle) else Part.Line(v1s, v1e)
            c2 = g2.Circle if isinstance(g2, Part.ArcOfCircle) else Part.Line(v2s, v2e)
            # --- НАХОДИМ ПЕРЕСЕЧЕНИЕ ---
            inter = c1.intersect(c2)
            pts_raw = inter if isinstance(inter, list) else [inter]
            pts = []
            for p in pts_raw:
                vec = self.to_v(p)
                if vec:
                    pts.append(App.Vector(vec.x, vec.y, 0))
            if not pts:
                App.Console.PrintWarning("Smart Surgery: Пересечение не найдено.\n")
                App.ActiveDocument.abortTransaction()
                return
            # --- ВЫБИРАЕМ ЛУЧШУЮ ТОЧКУ ПЕРЕСЕЧЕНИЯ ---
            target_v = None
            min_delta = float('inf')
            for pt in pts:
                d = 0
                for g in [g1, g2]:
                    if isinstance(g, Part.ArcOfCircle):
                        new_p = g.Circle.parameter(pt)
                        d += min(abs(new_p - g.FirstParameter),
                                 abs(new_p - g.LastParameter))
                    else:
                        d += min((pt - self.to_v(g.StartPoint)).Length,
                                 (pt - self.to_v(g.EndPoint)).Length)
                if d < min_delta:
                    min_delta, target_v = d, pt
            # --- ОПРЕДЕЛЯЕМ КАКИЕ КОНЦЫ ДВИГАТЬ ---
            def get_pi(g_idx, tv):
                click_v = self.click_points.get(g_idx)
                geo = sketch.Geometry[g_idx]
                sp = self.to_v(geo.StartPoint)
                ep = self.to_v(geo.EndPoint)
                if click_v is not None:
                    return 1 if (sp - click_v).Length < (ep - click_v).Length else 2
                return 1 if (sp - tv).Length < (ep - tv).Length else 2
            p1i = get_pi(idx1, target_v)
            p2i = get_pi(idx2, target_v)
            # --- ОПРЕДЕЛЯЕМ line_idx/line_pos и arc_idx/arc_pos ---
            geo1 = sketch.Geometry[idx1]
            geo2 = sketch.Geometry[idx2]
            if isinstance(geo1, Part.LineSegment):
                line_idx = idx1
                line_pos = p1i
                arc_idx = idx2
                arc_pos = p2i
            else:
                line_idx = idx2
                line_pos = p2i
                arc_idx = idx1
                arc_pos = p1i
            is_line_line = (not isinstance(geo1, Part.ArcOfCircle) and not isinstance(geo2, Part.ArcOfCircle))

            # --- ФОРМИРУЕМ СПИСОК ДВИЖУЩИХСЯ ТОЧЕК ---
            # Только концы линии и дуги — центр дуги НЕ трогаем!
            moving_targets = [(line_idx, line_pos), (arc_idx, arc_pos)]

            # --- ШАГ 5: ТОЧЕЧНАЯ ОЧИСТКА ОГРАНИЧЕНИЙ (API 2026) ---

            moving_indices = {m_idx for m_idx, _ in moving_targets}
            constraints_to_del = []
            for i, c in enumerate(sketch.Constraints):
                should_delete = False
                # 1. Ограничения, привязанные к конкретным движущимся точкам
                for m_idx, m_pos in moving_targets:
                    if (c.First == m_idx and c.FirstPos == m_pos) or \
                       (c.Second == m_idx and c.SecondPos == m_pos):
                        should_delete = True
                        break
                # 2. PointOnObject / Coincident между объектами, которые участвуют в движении
                if not should_delete:
                    if c.First in moving_indices and c.Second in moving_indices:
                        if c.Type in (
                            Sketcher.Constraint.PointOnObject,
                            Sketcher.Constraint.Coincident
                        ):
                            should_delete = True

                if should_delete:
                    constraints_to_del.append(i)
            # Удаляем в обратном порядке
            for i in reversed(constraints_to_del):
                sketch.delConstraint(i)

            # --- ШАГ 6: ДВИЖЕНИЕ ЛИНИИ И ДУГИ ---

            Gui.Selection.clearSelection()
            # Двигаем линию
            if is_line_line:
                # Двигаем только одну линию (вторую)
                sketch.moveGeometry(line_idx, line_pos, target_v, False)
            else:
                # Двигаем дугу
                geo = sketch.Geometry[arc_idx]
                # Сохраняем старые параметры дуги
                v_start_old = self.to_v(geo.StartPoint)
                v_end_old = self.to_v(geo.EndPoint)
                mid_old = geo.value((geo.FirstParameter + geo.LastParameter) / 2.0)
                # Двигаем нужный конец дуги
                sketch.moveGeometry(arc_idx, arc_pos, target_v, False)
                # Проверяем переворот дуги
                geo_new = sketch.Geometry[arc_idx]
                mid_new = geo_new.value((geo_new.FirstParameter + geo_new.LastParameter) / 2.0)
                chord_old = v_end_old - v_start_old

                flip_test = (mid_new - mid_old).dot(chord_old)
                if flip_test < 0:
                    # Коррекция центра дуги
                    center_new = self.to_v(geo_new.Center)
                    correction_dir = (mid_old - mid_new)
                    if correction_dir.Length > 1e-9:
                        correction = correction_dir.normalize() * 0.05
                        sketch.moveGeometry(arc_idx, 3, center_new + correction, False)

            # --- ШАГ 7: ВОССТАНОВЛЕНИЕ СВЯЗЕЙ ---

            # Всегда сшиваем линию и дугу/линию
            sketch.addConstraint(
                Sketcher.Constraint('Coincident', line_idx, line_pos, arc_idx, arc_pos)
            )
            # Если это линия + линия → выходим
            if is_line_line:
                return
            # Если это дуга + линия → добавляем PointOnObject
            if not is_line_line:
                sketch.addConstraint(
                    Sketcher.Constraint('PointOnObject', arc_idx, 3, line_idx)
                )
            sketch.solve()
            App.ActiveDocument.commitTransaction()
            App.ActiveDocument.recompute()
            App.Console.PrintMessage(">>> Smart Surgery 2026: Операция выполнена успешно.\n")

        except Exception as e:
            # Если что-то пошло не так, откатываем всё к состоянию до кликов
            if App.ActiveDocument:
                App.ActiveDocument.abortTransaction()
            App.Console.PrintError(f"Smart Surgery Error: {str(e)}\n")

    def finish(self):
        if not self.active: return
        self.active = False
        Gui.Selection.clearSelection()
        Gui.Selection.removeObserver(self)
        self._mw.removeEventFilter(self)
        self._mw.statusBar().clearMessage()
        view = Gui.activeView()
        if view and hasattr(view, 'graphicsView'):
            gv = view.graphicsView()
            gv.removeEventFilter(self)
            if gv.viewport(): gv.viewport().removeEventFilter(self)
        while QtWidgets.QApplication.overrideCursor() is not None:
            QtWidgets.QApplication.restoreOverrideCursor()
        App.Console.PrintMessage(">>> Smart Surgery: Выключен.\n")

if __name__ == "__main__":
    if hasattr(Gui, "SmartSurgeryInstance"): Gui.SmartSurgeryInstance.finish()
    Gui.SmartSurgeryInstance = SmartSurgeryTool()
    Gui.SmartSurgeryInstance.Activated()
