# версия 0.0.1 от 24-01-2026
import FreeCAD as App
import FreeCADGui as Gui
import Part
import Sketcher
from PySide6 import QtGui, QtCore, QtWidgets

class SmartSurgeryTool(QtCore.QObject):
    def __init__(self):
        super().__init__()
        self.active = False
        self._mw = Gui.getMainWindow()
        self.edges = []
        self.click_points = {}
        self.cursor_pixmap = self._create_circle_pixmap()
        self.custom_cursor = QtGui.QCursor(self.cursor_pixmap, 12, 12)

    def _create_circle_pixmap(self):
        size = 24
        pix = QtGui.QPixmap(size, size)
        pix.fill(QtCore.Qt.transparent)
        painter = QtGui.QPainter(pix)
        painter.setRenderHint(QtGui.QPainter.Antialiasing)
        painter.setPen(QtGui.QPen(QtGui.QColor(255, 0, 0, 180), 1.5))
        painter.drawEllipse(4, 4, size-8, size-8)
        painter.end()
        return pix

    def to_v(self, obj):
        """Абсолютно надежное извлечение вектора для API 2026"""
        try:
            if isinstance(obj, list):
                return self.to_v(obj[0]) if len(obj) > 0 else None
            # Если это GeomPoint или вектор с атрибутами
            if hasattr(obj, "Point"):
                p = obj.Point
                return App.Vector(float(p.x), float(p.y), float(p.z))
            if hasattr(obj, "x"):
                return App.Vector(float(obj.x), float(obj.y), float(obj.z))
            if hasattr(obj, "X"):
                return App.Vector(float(obj.X), float(obj.Y), float(obj.Z))
            # Принудительная пересборка, если это уже вектор
            v = App.Vector(obj)
            return App.Vector(float(v.x), float(v.y), float(v.z))
        except:
            return None

    def setEdit(self, doc_name, obj_name):
        """Этот метод ВНУТРИ SelectionObserver поймает смену инструмента"""
        if self.active:
            # Если пользователь кликнул по инструменту, фокус в Selection меняется
            # Если мы видим, что фокус ушел или изменился — выходим
            App.Console.PrintMessage(">>> Smart Surgery: Обнаружено переключение. Самовыключение.\n")
            QtCore.QTimer.singleShot(0, self.finish)


    def Activated(self):
        if self.active: return
        self.active = True
        self.edges = []
        self.click_points = {}
        QtWidgets.QApplication.setOverrideCursor(self.custom_cursor)
        Gui.Selection.addObserver(self)
        self._mw.installEventFilter(self)
        view = Gui.activeView()
        if view and hasattr(view, 'graphicsView'):
            gv = view.graphicsView()
            gv.installEventFilter(self)
            if gv.viewport(): gv.viewport().installEventFilter(self)
        self._mw.statusBar().showMessage("Smart Surgery: Выберите линию и дугу")
        App.Console.PrintMessage("\n>>> Smart Surgery: Активен. ESC для отмены.\n")

    def eventFilter(self, obj, event):
        if not self.active: return False
        
        # Выход только по ESC или ПКМ
        if (event.type() == QtCore.QEvent.KeyPress and event.key() == QtCore.Qt.Key_Escape) or \
           (event.type() == QtCore.QEvent.MouseButtonPress and event.button() == QtCore.Qt.RightButton):
            App.Console.PrintMessage(">>> Завершение работы инструмента по запросу пользователя.\n")
            QtCore.QTimer.singleShot(0, self.finish)
            return True
        return False


    def addSelection(self, doc_name, obj_name, sub, pnt):

        if not self.active or not sub or "Edge" not in sub:
            return
        
        doc = App.getDocument(doc_name)
        if not doc: return
        obj = doc.getObject(obj_name)
        if not obj or not obj.isDerivedFrom("Sketcher::SketchObject"): 
            return

        try:
            idx = int(sub.replace("Edge", "")) - 1
            self.click_points[idx] = self.to_v(pnt)
            
            if idx not in self.edges:
                self.edges.append(idx)
                App.Console.PrintMessage(f"Выбрано {len(self.edges)}/2: {sub}\n")
            
            if len(self.edges) == 2:
                # 1. Выполняем операцию
                self.execute(obj)
                
                # 2. СБРОС ДАННЫХ ДЛЯ ЦИКЛА (Вместо finish)
                self.edges = []
                self.click_points = {}
                Gui.Selection.clearSelection()
                
                self._mw.statusBar().showMessage("Smart Surgery: Готов к новой паре.")
                App.Console.PrintMessage(">>> Готов к следующей паре (ESC для выхода)...\n")
                
        except Exception as e:
            App.Console.PrintError(f"Ошибка выбора: {str(e)}\n")


    def reset_tool(self):
        """Сбрасывает накопленные данные для следующего шага, не выключая макрос"""
        self.edges = []
        self.click_points = {}
        Gui.Selection.clearSelection() # Снимаем подсветку с ребер
        self._mw.statusBar().showMessage("Smart Surgery: Готов к новой операции. Выберите 2 ребра.")
        App.Console.PrintMessage(">>> Готов к следующей паре...\n")

    def execute(self, sketch):
        if len(self.edges) < 2: return
        idx1, idx2 = self.edges[0], self.edges[1]
        
        App.ActiveDocument.openTransaction("Smart Surgery Fix 2026")
        try:
            g1, g2 = sketch.Geometry[idx1], sketch.Geometry[idx2]
            
            # 1. Извлекаем точки (используем ваш надежный to_v)
            v1s, v1e = self.to_v(g1.StartPoint), self.to_v(g1.EndPoint)
            v2s, v2e = self.to_v(g2.StartPoint), self.to_v(g2.EndPoint)
            
            # 2. Создаем бесконечные кривые для пересечения
            # В 2026 году для Line важно, чтобы это были именно Part.Line (бесконечные)
            if isinstance(g1, Part.ArcOfCircle):
                c1 = g1.Circle
            else:
                c1 = Part.Line(v1s, v1e)
                
            if isinstance(g2, Part.ArcOfCircle):
                c2 = g2.Circle
            else:
                c2 = Part.Line(v2s, v2e)
            
            # Находим пересечение
            inter_results = c1.intersect(c2)
            
            # 3. Извлекаем точки
            pts_raw = inter_results if isinstance(inter_results, list) else [inter_results]
            pts = []
            for p in pts_raw:
                vec = self.to_v(p)
                if vec:
                    # Для стабильности скетчера обнуляем Z результата
                    pts.append(App.Vector(vec.x, vec.y, 0))
            
            if not pts:
                App.Console.PrintWarning("Smart Surgery: Пересечение не найдено.\n")
                App.ActiveDocument.abortTransaction()
                return

            # Выбор ближайшей точки пересечения
            target_v = None
            min_delta = float('inf')
            for pt in pts:
                d = 0
                for g in [g1, g2]:
                    if isinstance(g, Part.ArcOfCircle):
                        new_p = g.Circle.parameter(pt)
                        d += min(abs(new_p - g.FirstParameter), abs(new_p - g.LastParameter))
                    else:
                        d += min((pt-self.to_v(g.StartPoint)).Length, (pt-self.to_v(g.EndPoint)).Length)
                if d < min_delta:
                    min_delta, target_v = d, pt

            # Спецкейс: центр дуги
            arc_idx = idx1 if isinstance(g1, Part.ArcOfCircle) else (idx2 if isinstance(g2, Part.ArcOfCircle) else None)
            line_idx = idx2 if arc_idx == idx1 else idx1
            is_special = False
            if arc_idx is not None:
                c_v = self.to_v(sketch.Geometry[arc_idx].Circle.Center)
                l_g = sketch.Geometry[line_idx]
                if (c_v - self.to_v(l_g.StartPoint)).Length < 1e-4 or (c_v - self.to_v(l_g.EndPoint)).Length < 1e-4:
                    is_special = True

            def get_pi(g_idx, tv):
                click_v = self.click_points.get(g_idx)
                geo = sketch.Geometry[g_idx]
                if click_v:
                    return 1 if (self.to_v(geo.StartPoint)-click_v).Length < (self.to_v(geo.EndPoint)-click_v).Length else 2
                return 1 if (self.to_v(geo.StartPoint)-tv).Length < (self.to_v(geo.EndPoint)-tv).Length else 2

            # Определение индексов точек (1 - Start, 2 - End)
            p1i = get_pi(idx1, target_v)
            p2i = get_pi(idx2, target_v)

             # 5. СТРОГАЯ ОЧИСТКА ВЕРШИН (Только для пары из self.edges)
            removed = True
            while removed:
                removed = False
                for i, c in enumerate(sketch.Constraints):
                    is_t = False
                    
                    # Точки, которые мы перемещаем в данном цикле
                    moving_targets = [(idx1, p1i), (idx2, p2i)]
                    if is_special:
                        moving_targets.append((arc_idx, 3)) # Центр дуги

                    for m_idx, m_pos in moving_targets:
                        # Условие 1: Это ограничение совпадения (Coincident) 
                        # именно на нашей перемещаемой вершине
                        if (c.First == m_idx and c.FirstPos == m_pos) or \
                           (c.Second == m_idx and c.SecondPos == m_pos):
                            is_t = True
                        
                        # Условие 2: Наша перемещаемая точка привязана к телу через PointOnObject
                        elif c.Type == 'PointOnObject':
                            if (c.First == m_idx and c.FirstPos == m_pos) or \
                               (c.Second == m_idx and c.SecondPos == m_pos):
                                is_t = True
                        
                        # Условие 3: Любое ограничение, связывающее две наши выбранные геометрии 
                        # (Например, если дуга лежит на линии, которую мы тоже выбрали)
                        elif (c.First in self.edges and c.Second in self.edges):
                            # Но только если это касается наших перемещаемых вершин
                            if (c.First == m_idx and c.FirstPos == m_pos) or \
                               (c.Second == m_idx and c.SecondPos == m_pos):
                                is_t = True

                        if is_t: break
                    
                    if is_t:
                        sketch.delConstraint(i)
                        removed = True
                        break 

            # После тотальной очистки "успокаиваем" решатель перед перемещением
            sketch.solve()


            # Обновление геометрии
            # 6. ОБНОВЛЕНИЕ ГЕОМЕТРИИ (Актуально для FreeCAD 1.0+)
            def upd(geo, v, pi):
                # Создаем новый объект геометрии на базе старого
                if isinstance(geo, Part.LineSegment):
                    vs, ve = self.to_v(geo.StartPoint), self.to_v(geo.EndPoint)
                    return Part.LineSegment(v, ve) if pi == 1 else Part.LineSegment(vs, v)
                elif isinstance(geo, Part.ArcOfCircle):
                    vs, ve = self.to_v(geo.StartPoint), self.to_v(geo.EndPoint)
                    vst = ve if pi == 1 else vs
                    vm = geo.value((geo.FirstParameter + geo.LastParameter) / 2.0)
                    try:
                        return Part.ArcOfCircle(v, vm, vst) if pi == 1 else Part.ArcOfCircle(vst, vm, v)
                    except: return geo
                return geo

            # --- ШАГ 6: ХИРУРГИЧЕСКОЕ ПЕРЕМЕЩЕНИЕ (API 2026) ---
            
            # 1. Снимаем выделение, чтобы не блокировать графический кэш
            Gui.Selection.clearSelection()

            # 2. Прямое перемещение вершин (сохраняет ID gXXXX.edgeY)
            try:
                # В 2026 это самый стабильный способ
                sketch.moveGeometry(idx1, p1i, target_v, False)
                sketch.moveGeometry(idx2, p2i, target_v, False)
            except AttributeError:
                # Резервный путь для старых сборок
                sketch.movePoint(idx1, p1i, target_v, False)
                sketch.movePoint(idx2, p2i, target_v, False)

            # 3. "Успокаиваем" решатель DogLeg после перемещения
            sketch.solve() 

            # 4. Проверка радиуса дуги (защита от "SetRadius" ошибки)
            for idx in [idx1, idx2]:
                geo = sketch.Geometry[idx]
                # Если это дуга и её радиус стал дегенеративным (0), 
                # Скетчер 1.0 может выдать ошибку. Мы фиксируем его.
                if hasattr(geo, "Radius") and geo.Radius < 1e-6:
                    # В этом редком случае можно применить вашу функцию upd 
                    # или просто сбросить параметры через setGeometry, если доступно
                    pass

            # 5. НАЛОЖЕНИЕ НОВЫХ ОГРАНИЧЕНИЙ (Сшивка)
            sketch.addConstraint(Sketcher.Constraint('Coincident', idx1, p1i, idx2, p2i))
            
            if is_special:
                # Восстанавливаем связь центра дуги с линией
                sketch.addConstraint(Sketcher.Constraint('PointOnObject', arc_idx, 3, line_idx))

            # 6. ЗАВЕРШЕНИЕ ТРАНЗАКЦИИ
            App.ActiveDocument.commitTransaction()
            
            # Принудительный пересчет для обновления вьюера
            sketch.recompute()
            
            App.Console.PrintMessage(">>> Smart Surgery: Операция завершена успешно.\n")

        except Exception as e:
            # Если что-то пошло не так, откатываем всё к состоянию до кликов
            if App.ActiveDocument:
                App.ActiveDocument.abortTransaction()
            App.Console.PrintError(f"Smart Surgery Error: {str(e)}\n")



    def finish(self):
        if not self.active: return
        self.active = False
        Gui.Selection.clearSelection()
        Gui.Selection.removeObserver(self)
        self._mw.removeEventFilter(self)
        self._mw.statusBar().clearMessage()
        view = Gui.activeView()
        if view and hasattr(view, 'graphicsView'):
            gv = view.graphicsView()
            gv.removeEventFilter(self)
            if gv.viewport(): gv.viewport().removeEventFilter(self)
        while QtWidgets.QApplication.overrideCursor() is not None:
            QtWidgets.QApplication.restoreOverrideCursor()
        App.Console.PrintMessage(">>> Smart Surgery: Выключен.\n")

if __name__ == "__main__":
    if hasattr(Gui, "SmartSurgeryInstance"): Gui.SmartSurgeryInstance.finish()
    Gui.SmartSurgeryInstance = SmartSurgeryTool()
    Gui.SmartSurgeryInstance.Activated()
